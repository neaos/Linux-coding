# **文件IO的说明：** #


## /*  copy_file.c  */ ##


文件基本操作的实例，基本功能是从一个文件（源文件）中读取最后10KB数据并到另一个文件（目标文件）。在实例中源文件是以只读方式打开，目标文件是以只写方式打开（可以是读写方式） 。若目标文件不存在，可以创建并设置权限的初始值为 644，即文件所有者可读可写，文件所属组和其他用户只能读。

## /* lock_set.c */ ##
使用 fcntl()函数的文件记录锁功能的代码实现。 在该代码中， 首先给 flock 结构体的对应位赋予相应的值。接着使用两次 fcntl()函数，分别用于判断文件是否可以上锁和给相关文件上锁，这里用到的 cmd 值分别为 F_GETLK 和 F_SETLK（或 F_SETLKW） 。

用 F_GETLK 命令判断是否可以进行 flock 结构所描述的锁操作：若可以进行，则 flock 结构的 l_type 会被设置为 F_UNLCK，其他域不变；若不可行，则 l_pid 被设置为拥有文件锁的进程号，其他域不变。

用 F_SETLK 和 F_SETLKW 命令设置 flock 结构所描述的锁操作，后者是前者的阻塞版。

## /* write_lock.c */ ##
文件写入锁的测试用例，这里首先创建了一个 hello 文件，之后对其上写入锁，最后释放写入锁。


## /* fcntl_read.c */ ##
文件读取锁的测试用例

## /* multiplex_select */ ##
通过调用 select()函数来监听 3 个终端的输入 （分别重定向到两个管道文件的虚拟终端以及主程序所运行的虚拟终端） ，并分别进行相应的处理。在这里我们建立了一个 select()函数监视的读文件描述符集，其中包含 3 个文件描述符，分别为一个标准输入文件描述符和两个管道文件描述符。通过监视
主程序的虚拟终端标准输入来实现程序的控制（例如：程序结束） ；以两个管道作为数据输入，主程序将从两个管道读取的输入字符串写入到标准输出文件（屏幕） 。
为了充分表现 select()调用的功能，在运行主程序的时候，需要打开 3 个虚拟终端：首先用 mknod 命令创建两个管道 in1 和 in2。接下来，在两个虚拟终端上分别运行 cat>in1 和 cat>in2。同时在第三个虚拟终端上运行主程序。在程序运行之后，如果在两个管道终端上输入字符串，则可以观察到同样的内容将在主程序的虚拟终端上逐行显示。如果想结束主程序，只要在主程序的虚拟终端下输入以‘q’或‘Q’字符开头的字符串即可。如果三个文件一直在无输入状态中，则主程序一直处于阻塞状态。为了防止无限期的阻塞，在 select 程序中设置超时值（本实例中设置为 60s） ，当无输入状态持续到超时值时，主程序主动结束运行并退出。而 poll 程序中依然无限等待，当然 poll()函数也可以设置超时参数。

## /* multiplex_poll.c */ ##
poll 机制与 select 机制相比效率更高，使用范围更广，下面给出用 poll()函数实现同样功能的代码。

